# R code for stand-alone iDEP analysis 
# by Steven Xijin Ge, South Dakota State University,  gexijin@gmail.com  
# Generated by  iDEP 0.82  hosted at http://ge-lab.org/idep/  Thu Mar 14 16:23:48 2019 
#uses Biomart 92
#modified by Sara Di Rienzi (2020)

##########################
# 1. Read data
########################## 
source('Fig1BSupplFig1_iDEP_core_functions.R') 
library("Polychrome")
library("ggplot2")
library("gridExtra")

#note that not all of the functions are active in this script

#look for main function in the core functions file
  # Input files 
 # Expression file has to use Ensembl for gene ID. Otherwise, use custom pathway database with matching IDs. 
 inputFile <- 'GeneCountData.csv'  # Expression matrix
 # Experiment design file
 sampleInfoFile <- 'RNASeqMetadata.csv'  
  #Gene symbols, location etc. 
 geneInfoFile <- 'mart_exportensemblChr37moreinfo.txt'  
 # pathway database in SQL; can be GMT format 
 geneSetFile <- 'Human__hsapiens_gene_ensembl.db'   #try to get this updated
 STRING10_speciesFile <- 'https://raw.githubusercontent.com/iDEP-SDSU/idep/master/shinyapps/idep/STRING10_species.csv' 

 # Parameters
 input_missingValue <- 'geneMedianInGroup'	#Missing values imputation method
 input_dataFileFormat <- 1	#1- read counts, 2 FKPM/RPKM or DNA microarray
 
 input_minCounts <- 1	#Min counts
 input_NminSamples <- 5	#Minimum number of samples 
 input_countsLogStart <- 2	#Pseudo count for log CPM
 input_CountsTransform <- 3 #3	#Methods for data transformation of counts. 1-EdgeR's logCPM; 2-VST; 3-rlog 

 #Read data files
 readData.out <- readData(inputFile) 
 readSampleInfo.out <- readSampleInfo(sampleInfoFile) 
 input_selectOrg ="Human__hsapiens" #"BestMatch" #Human__hsapiens" 
 input_selectGO <- NULL 	#Gene set category 
 input_noIDConversion = TRUE  
 allGeneInfo.out <- geneInfo(geneInfoFile)   ##maybe modify these
 converted.out = NULL 
 convertedData.out <- convertedData()	 
 #nGenesFilter()  
 convertedCounts.out <- convertedCounts()  # converted counts, just for compatibility  #save this to do DEseq2 outside of 
 #readCountsBias()  # detecting bias in sequencing depth 
write.table( convertedData.out, file="convertedrlogcounts.txt",sep="\t",quote=FALSE)
 
 

##########################
# 2. Pre-Process 
########################## 

 par(mar=c(10,4,2,2),oma=c(3,1,0,0)) 
 # barplot of total read counts		
 
 if(nlevels(groups)<=1 | nlevels(groups) >20 )   #not using
  col1 = 'green'  else  #not using
  col1 = rainbow(nlevels(groups))[ groups ] #not using
   
  #Figure of library sizes
parDefault = par() 
x <- readData.out$rawCounts
groups = as.factor( detectGroups(colnames(x ) ) )  #these are the names of the samples
colours2 = light.colors(nlevels(groups))[ groups ]
par(mar=c(10,4,2,2)) 
barplot( colSums(readData.out$rawCounts)/1e6, 
		col=colours2,las=3,ylab="Total read counts (millions)",names.arg = c("U.LDM_A1","U.LDM_A2","U.LDM_A3",
		                                                                      "U.LDM_B1","U.LDM_B2","U.LDM_B3",
		                                                                      "U.6475_A1","U.6475_A2","U.6475_A3",
		                                                                      "U.6475_B1","U.6475_B2","U.6475_B3",
		                                                                      "I.LDM_A1","I.LDM_A2","I.LDM_A3",
		                                                                      "I.LDM_B1","I.LDM_B2","I.LDM_B3",
		                                                                      "I.6475_A1","I.6475_A2","I.6475_A3",
		                                                                      "I.6475_B1","I.6475_B2","I.6475_B3",
		                                                                      "I.1793_A1","I.1793_A2","I.1793_A3",
		                                                                      "I.1793_B1","I.1793_B2","I.1793_B3"))  
title(xlab="Libraries",line=6)
dev.off()
mean(colSums(readData.out$rawCounts))

 
 #make a ggplot of read counts using the polychrome package

 
 # Box plot 
 x = readData.out$data 
 boxplot(x, las = 2, col=col1,
    ylab='Transformed expression levels',
    main='Distribution of transformed data') 
 
 #histogram of raw data
 rawdata<-readData.out$rawCounts
 densityPlotraw()

 # Density plot 
 par(parDefault) 
 densityPlot()   

 # Scatter plot of the first two samples 
 plot(x[,1:2],xlab=colnames(x)[1],ylab=colnames(x)[2], 
    main='Scatter plot of first two samples') 

 #plot gene or gene family
 #input_selectOrg ="BestMatch"
 ensemblename = 'FALSE'  #TRUE or FALSE depending on whether using the ensemble name or the gene name
 input_geneSearch <- 'ENSG00000228252' #'ENSG00000096395' #"ENSG00000001630" 'MT-CO1'  #'MT-CO1'# "ENSG00000001630" #	#Gene ID for searching 
 genePlot() 
 input_useSD <- 'TRUE'	#Use standard deviation instead of standard error in error bar? 
 #list of genes to plot out
 
 genelist<-c("Neurog3","Neurod1","Sox4","Chga","Chgb","PYY","Tph1",'SCT ',"Alpi","Apoa1","Apoa4","Fabp1","Gpbar1","Gpr119","CCK","CREB3L3","Lrrc19",'Lrrc26',"Lct ","MTTP","Lpar1 ","Maf ", "Hnf4g","Rxra","zbtb7b")
 geneplots<-list()
 ensemblename = 'FALSE'
 for (i in 1:length(genelist)) {
  gene<-genelist[i]
  input_selectOrg ="BestMatch"
  exactmatch = TRUE;
  input_useSD <- 'TRUE'
  input_geneSearch <- gene
 geneplots[[i]]<-geneBarPlotError()  
 }
 
 genedata<-list()
 #to get the stats on induced vs uninduced
 for (i in 1:length(genelist)) {
   gene<-genelist[i]
   input_selectOrg ="BestMatch"
   input_useSD <- 'TRUE'
   input_geneSearch <- gene
   genedata[[i]]<-geneexpressiondata()  
#create a dataframe here
 }
 
 #to make GeTMM values
 #start with readcount data
 View(convertedCounts.out) #this is the read count data
 #need to add gene length in kb
 #calculate rpk
#load in file with genelength, using the original file from the company, just in case
 genelengthfile<-read.delim(file="readcount_genename.txt",header=TRUE)
 genelengthfile$genelength=(genelengthfile$End- genelengthfile$Start+1)/1000
 genelnsub<-data.frame("Gene" = genelengthfile$Gene,"genelength" = genelengthfile$genelength)
 readcounts<-merge(genelnsub,convertedCounts.out,by.y="row.names",by.x ="Gene",all.y=TRUE )
 #checked the dimensions and they are good
 row.names(readcounts)<-readcounts$Gene
 readcounts<-readcounts[,-1]  #remove the extra column with the genename
 readcountsrpk<-(readcounts[,2:ncol(readcounts)]/readcounts[,1])
 #remove the column with the genelenght
 #using EDGER, where group is the at the level just above replicates (ULDM4A)
 rpk.norm <- DGEList(counts=readcountsrpk,group=c("ULDMA","ULDMA","ULDMA","ULDMB","ULDMB","ULDMB",
                                                  "U6475A","U6475A","U6475A","U6475B","U6475B","U6475B",
                                                  "ILDMA","ILDMA","ILDMA","ILDMB","ILDMB","ILDMB",
                                                  "I6475A","I6475A","I6475A","I6475B","I6475B","I6475B",
                                                  "I1793A","I1793A","I1793A","I1793B","I1793B","I1793B"))  #creates edger object
 rpk.norm<-calcNormFactors(rpk.norm) #does the normalization to scale the raw library sizes
 norm.counts.rpk.edger<-cpm(rpk.norm) #converts data to CPM and will add a pseudocount of 2 if log = TRUE. Then plot these
 #write.table(norm.counts.rpk.edger,"genecountsforplotting_GeTMM.txt",sep="\t")
 
 
 
 for (i in 1:length(genelist)) {
   gene<-genelist[i]
   input_selectOrg ="BestMatch"
   exactmatch = TRUE;
   input_useSD <- 'TRUE'
   input_geneSearch <- gene
   geneplots[[i]]<-geneBarPlotError2(norm.counts.rpk.edger)  
 }
 
 for (i in 1:length(genelist)) {
   gene<-genelist[i]
   input_selectOrg ="BestMatch"
   input_useSD <- 'TRUE'
   input_geneSearch <- gene
   genedata[[i]]<-geneexpressiondata2( norm.counts.rpk.edger)  
   #create a dataframe here
 }
 
 
 geneBarPlotError3 <- function(normreadcountdata) {
   x <- normreadcountdata
   
   Symbols <- rownames(x)
   if( input_selectOrg != "NEW") {
     ix = match( rownames(x), allGeneInfo.out[,1])
     if( sum( is.na(allGeneInfo.out$symbol )) != dim(allGeneInfo.out )[1] ) {  # symbol really exists? 
       Symbols = as.character( allGeneInfo.out$symbol[ix] )
       Symbols[which( nchar(Symbols) <= 2 ) ] <- rownames(x) [which( nchar(Symbols) <= 2 ) ] #if the genename is 2 characters or shorter, use the ensembl name
     }
   }
   x = as.data.frame(x)
   if (ensemblename=="FALSE"){x$Genes = Symbols}
   else {x$Genes = rownames(x)}
   if (exactmatch == FALSE) { #if don't want an exact match
     ix = which(regexpr(  paste("^" , toupper(input_geneSearch),sep="")   ,toupper(x$Genes)) > 0)
   }
   else { #do an exact match
     #if(grepl(" ", input_geneSearch)  )  # if there is space character, do exact match
     ix = match(gsub(" ","", toupper(input_geneSearch)),x$Genes)
   }
   # too few or too many genes found
   if(length(ix) == 0 | length(ix) > 50 ) return(NULL)
   # no genes found
   
   mdf = melt(x[ix,],id.vars="Genes", value.name="value", variable.name="samples")
   mdf$count = 1
   g = detectGroups(mdf$samples)
   Means = aggregate(mdf$value,by=list( g, mdf$Genes ), FUN = mean, na.rm=TRUE  )
   SDs = aggregate(mdf$value,by=list( g, mdf$Genes ), FUN = sd, na.rm=TRUE  )
   Ns = aggregate(mdf$count, by= list(g, mdf$Genes) , FUN = sum  )
   summarized = cbind(Means,SDs[,3],Ns[,3])
   colnames(summarized)= c("Samples","Genes","Mean","SD","N")
   summarized$SE = summarized$SD / sqrt(summarized$N)	
   summarized$ymax = summarized$Mean+summarized$SD #+ (summarized$Mean+summarized$SD)/5
   maxy<-max(summarized$ymax)
   colours = unname(light.colors(nlevels(as.factor(summarized$Samples))))
   names(colours)<-as.factor(summarized$Samples)
   summarized$Samples <- factor(summarized$Samples, levels = summarized$Samples[c(9,10,11,12,7,8,5,6,3,4,1,2)])  #this needs to be changed for the specific set of samples
   
   #http://www.sthda.com/english/wiki/ggplot2-barplots-quick-start-guide-r-software-and-data-visualization
   p2 <- ggplot(summarized, aes(x=Genes, y=Mean,fill=Samples) ) + # data & aesthetic mapping
     geom_bar(stat="identity", position=position_dodge()) + # bars represent average
     geom_errorbar(aes(ymin=Mean-SE, ymax=Mean+SE), width=0.2,position=position_dodge(.9)) +
     labs(y="Expression Level (log2(CPM+2))") +
     scale_fill_manual(name = "Samples",values=colours)
    
   if(input_useSD == TRUE) { 
     p2 <- ggplot(summarized, aes(x=Genes, y=Mean,fill=Samples) ) + # data & aesthetic mapping
       geom_bar(stat="identity", position=position_dodge()) + # bars represent average
       geom_errorbar(aes(ymin=Mean-SD, ymax=Mean+SD), width=0.2,position=position_dodge(.9)) +
       labs(y="Expression Level") +
       # geom_hline(yintercept=1)+
       scale_fill_manual(name = "Samples",values=colours)+
       geom_segment(data = subset(msegments,msegments$GeneID=='ENSG00000090402'), 
        mapping = aes(x= xstart, xend = xend, y = ymax, yend = yend, group=FCComparison,fill=NA,color=FCvalue),lwd=5 )+
    scale_color_continuous(low="blue",high="red",limits=c(-2,2))+
       geom_text(data=subset(msegments,msegments$GeneID=='ENSG00000090402'),mapping=aes(x=xmid,y=ymax,label=FCround,fill=NA),colour="white")
      }
   
   p2 <- p2 +  theme(plot.title = element_text(size = 16,hjust = 0.5)) + # theme(aspect.ratio=1) +
     theme_classic() +
     theme(
       axis.ticks = element_line(colour="black"),
       axis.line.x = element_line(colour = "black"),
       axis.line.y = element_line(colour = "black"),
       axis.title.x = element_blank(),
       axis.title.y= element_text(size=16, colour="black"),
       axis.text.x= element_text(size = 14, colour="black"),
       axis.text.y= element_text(size=16, colour="black"),#legend.text=element_text(size=16)
       legend.position="none")
   
   
   p2
 }
 
 
#ggplot here
 
#Supp Fig 1 & 2
 

#Supplemental Fig 1
 #enterocyte genes
#pdf("",width=9)
grid.arrange(geneplots[[9]],geneplots[[10]],geneplots[[11]],geneplots[[12]],geneplots[[16]],geneplots[[19]],geneplots[[20]],geneplots[[21]],geneplots[[22]],
             geneplots[[23]],geneplots[[24]],geneplots[[25]],ncol=4)
#dev.off()

#Supplemental Fig 2
#enteroendocrine genes
#pdf(file="",width=9)
grid.arrange(geneplots[[1]],geneplots[[2]],geneplots[[3]],geneplots[[4]],geneplots[[5]],geneplots[[6]],
             geneplots[[7]],geneplots[[8]],geneplots[[13]],geneplots[[14]],geneplots[[15]],geneplots[[18]],ncol=4)
#dev.off()




##########################
# 5. PCA and beyond 
##########################
#make sure you used rlog!
 input_selectFactors <- 'treatment_'	#Factor coded by color
 input_selectFactors2 <- 'induction_'	#Factor coded by shape
 input_tsneSeed2 <- 0	#Random seed for t-SNE 
 #PCA, MDS and t-SNE plots
 PCAplot()	

 #Fig 1B
 pdf(file="RNASeq_MDSplot.pdf",width=9, height=9)
 MDSplot("1","2")   #use # of dimension you are interested in; can plot up to dim4
 dev.off()
 ## calculate the percentage of variation that each MDS axis accounts for...
 fit = cmdscale( dist(t(convertedData.out) ), eig=T, x.ret=TRUE,k=4)
 mds.var.per <- round(fit$eig/sum(fit$eig)*100, 1)
 mds.var.per. #shows the percent variation for each dimension
# [1] 72.1 13.0  3.1  1.9  1.5  1.4  0.9  0.7  0.5  0.4  0.4  0.3  0.3  0.3  0.3  0.3  0.3  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.1  0.0

 
 tSNEplot()  
 
 #do permanova on induction state; PMA; treatments
 #need to create subsets of the data as induced and non-induced
 
 library("vegan") 
 library("phyloseq")
 library("Biostrings")
 
 
 dm<-as.data.frame(t(convertedData.out))
 metadata<-as.data.frame(readSampleInfo.out)  
 
 
 #delete this 
 # otumatrix<-dm[complete.cases(dm), ]
 # sampletable<-otu_table(otumatrix,taxa_are_rows=FALSE)
 # samplemetadata<-sample_data(metadata)
 # sample_names(samplemetadata)<-row.names(samplemetadata)

 #delete this
 # map<-merge_phyloseq(dm, sampletable)
 # jac<-ordinate(map, method="PCoA","jaccard")
 # plot_ordination(map ,jac) 
 # ordplotJac<-plot_ordination(map ,jac, justDF=TRUE )
 # ordtable_Jac<-as.data.frame(ordplotJac)
 

 
 
 #for the libraries:
 adonis2(dm ~ induction_ +treatment_+replicate_+treatmentinduction_, data = metadata,method="jaccard")
 
 # Call:
 #   adonis(formula = dm ~ induction_ + treatment_ + replicate_ +      treatmentinduction_, data = metadata, method = "jaccard") 
 # 
 # Terms added sequentially (first to last)
 # 
 # Df SumsOfSqs   MeanSqs F.Model      R2 Pr(>F)    
 # induction_           1  0.030417 0.0304174  95.224 0.65224  0.001 ***
 #   treatment_           2  0.002626 0.0013129   4.110 0.05631  0.005 ** 
 #   replicate_           1  0.005075 0.0050749  15.887 0.10882  0.001 ***
 #   treatmentinduction_  1  0.000851 0.0008506   2.663 0.01824  0.072 .  
 # Residuals           24  0.007666 0.0003194         0.16439           
 # Total               29  0.046635                   1.00000           
 # ---
 #   Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
 
 adonis2(dm ~ induction_ +treatment_+replicate_+treatmentinduction_, data = metadata,method="euclidean")
 # Call:
 #   adonis(formula = dm ~ induction_ + treatment_ + replicate_ +      treatmentinduction_, data = metadata, method = "euclidean") 
 # 
 # Permutation: free
 # Number of permutations: 999
 # 
 # Terms added sequentially (first to last)
 # 
 # Df SumsOfSqs MeanSqs F.Model      R2 Pr(>F)    
 # induction_           1     62885   62885 120.763 0.70803  0.001 ***
 #   treatment_           2      3925    1962   3.768 0.04419  0.011 *  
 #   replicate_           1      8168    8168  15.685 0.09196  0.001 ***
 #   treatmentinduction_  1      1342    1342   2.578 0.01511  0.082 .  
 # Residuals           24     12497     521         0.14071           
 # Total               29     88817                 1.00000           
 # ---
 #   Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
 
 
 
 
 #Read gene sets for pathway analysis using PGSEA on principal components 
 input_selectGO6 <- 'GOBP' 
 GeneSets.out <-readGeneSets( geneSetFile,
    convertedData.out, input_selectGO6,input_selectOrg,
    c(input_minSetSize, input_maxSetSize)  )  
 PCApathway() # Run PGSEA analysis 
 cat( PCA2factor() )   #The correlation between PCs with factors 

##########################
# 6. DEG1 
##########################
 
 input_CountsDEGMethod <- 3	#DESeq2= 3,limma-voom=2,limma-trend=1 
 input_limmaPval <- 0.1	#FDR cutoff
 input_limmaFC <- 2	#Fold-change cutoff
 input_selectModelComprions <- c('treatmentinduction_: U6475 vs. ULDM', 'treatmentinduction_: I6475 vs. ILDM',
                                 'treatmentinduction_: I1793 vs. ILDM', 'treatmentinduction_: I6475 vs. I1793', 
                                'treatmentinduction_: I6475 vs. U6475',
                                'treatmentinduction_: ILDM vs. ULDM') 	 #'treatmentinduction_: IPMA vs. ILDM',,#Selected comparisons; can do multiples
 input_selectFactorsModel <- c('treatmentinduction_')	#Selected comparisons
 input_selectInteractions <- NULL 	#Selected comparisons
 factorReferenceLevels.out <- c('treatmentinduction_:ULDM', 'treatmentinduction_:ILDM') 
 
 #for all analyses
 input_selectBlockFactorsModel <- c('replicate_') 	#Selected comparisons 

 
 
 limma.out <- limma()
 View(limma.out$topGenes$`U6475-ULDM`)  #this has foldchange and pvalues
 limma.out$comparisons
 limma.out$Exp.type #the model
 DEG.data.out<-DEG.datafixed()  #uses the results from limma.out
 write.table( DEG.data.out,'out.txt',row.names = FALSE,sep="\t" )  

 sigGeneStatsTable() # number of DEGs as table 
 
 #if want to get the complete DEGSe2 output, 
 rawCounts<-convertedCounts.out
 modelFactors<-input_selectFactorsModel
 selectedComparisons<-input_selectModelComprions
 blockFactor<-input_selectBlockFactorsModel
 sampleInfo<-readSampleInfo.out
 referenceLevels<-factorReferenceLevels.out
 #then run lines 2244-2379 and print out totaloutput. repeat for each comparison in the loop at 2370

